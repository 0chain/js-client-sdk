<html>
  <head>
    <meta charset="utf-8">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/BrowserFS/2.0.0/browserfs.js"></script>
    <script src="wasm_exec.js"></script>

<!--
  This section largely taken from, in order to get Golang's filesystem working in browser. 
  You can probably ignore this.

  https://dev.to/wcchoi/browser-side-pdf-processing-with-go-and-webassembly-13hn
-->
<script>
  // Taken from this excellent article:
  //
  // Configures BrowserFS to use the InMemory file system.
  BrowserFS.configure({ fs: "InMemory" }, function(e) {
    if (e) {
      // An error happened!
      throw e;
    }
    // Otherwise, BrowserFS is ready-to-use!
    var fs = BrowserFS.BFSRequire('fs');
    var Buffer = BrowserFS.BFSRequire('buffer').Buffer;
    window.fs = fs;
    window.Buffer = Buffer;

    window.fs.constants = {
      O_RDONLY: 0,
      O_WRONLY: 1,
      O_RDWR: 2,
      O_CREAT: 64,
      O_EXCL: 128,
      O_NOCTTY: 256,
      O_TRUNC: 512,
      O_APPEND: 1024,
      O_DIRECTORY: 65536,
      O_NOATIME: 262144,
      O_NOFOLLOW: 131072,
      O_SYNC: 1052672,
      O_DIRECT: 16384,
      O_NONBLOCK: 2048,
    };

    let outputBuf = "";

    // Taken from
    // https://github.com/wcchoi/go-wasm-pdfcpu/blob/master/wasm_exec.js#L186
    const encoder = new TextEncoder("utf-8");
    const decoder = new TextDecoder("utf-8");

    // Largely taken from
    // https://github.com/wcchoi/go-wasm-pdfcpu/blob/master/wasm_exec.js#L62
    window.fs.writeSyncOriginal = window.fs.writeSync
    window.fs.writeSync = function(fd, buf) {
      // console.log('d2');
      if (fd === 1 || fd === 2) {
        outputBuf += decoder.decode(buf);
        const nl = outputBuf.lastIndexOf("\n");
        if (nl != -1) {
          console.log(outputBuf.substr(0, nl));
          outputBuf = outputBuf.substr(nl + 1);
        }
        return buf.length;
      } else {
        return window.fs.writeSyncOriginal(...arguments);
      }
    };

    window.fs.writeOriginal = window.fs.write
    window.fs.write = function(fd, buf, offset, length, position, callback) {
      console.log('d1');
      if (fd === 1 || fd === 2) {
        if (offset !== 0 || length !== buf.length || position !== null) {
          throw new Error("not implemented");
        }
        const n = this.writeSync(fd, buf);
        callback(null, n, buf);
      } else {
        // buf:
        arguments[1] = window.Buffer.from(arguments[1]);
        return window.fs.writeOriginal(...arguments);
      }
    };

    window.fs.openOriginal = window.fs.open
    window.fs.open = function(path, flags, mode, callback) {
      var myflags = 'r';
      var O = window.fs.constants;

      // Convert numeric flags to string flags
      // FIXME: maybe wrong...
      if (flags & O.O_WRONLY) { // 'w'
        myflags = 'w';
        if (flags & O.O_EXCL) {
          myflags = 'wx';
        }
      } else if (flags & O.O_RDWR) { // 'r+' or 'w+'
        if (flags & O.O_CREAT && flags & O.O_TRUNC) { // w+
          if (flags & O.O_EXCL) {
            myflags = 'wx+';
          } else {
            myflags = 'w+';
          }
        } else { // r+
          myflags = 'r+';
        }
      } else if (flags & O.O_APPEND) { // 'a'
        throw new Error("Not implmented");
      }
      // TODO: handle other cases

      console.log('d0', flags, O, myflags);
      // myflags = "w+";
      path = "/asdf"; // TODO: gotta unhardcode this.

      return window.fs.openOriginal(path, myflags, mode, callback);
    };

    window.fs.fstatOriginal = window.fs.fstat;
    window.fs.fstat = function(fd, callback) {
      return window.fs.fstatOriginal(fd, function() {
        var retStat = arguments[1];
        if (retStat) {
          delete retStat['fileData'];
          retStat.atimeMs = retStat.atime.getTime();
          retStat.mtimeMs = retStat.mtime.getTime();
          retStat.ctimeMs = retStat.ctime.getTime();
          retStat.birthtimeMs = retStat.birthtime.getTime();
        }
        return callback(arguments[0], retStat);

      });
    };

    window.fs.closeOriginal = window.fs.close;
    window.fs.close = function(fd, callback) {
      return window.fs.closeOriginal(fd, function() {
        if(typeof arguments[0] === 'undefined') arguments[0] = null;
        return callback(...arguments);
      });
    }

    window.fs.statOriginal = window.fs.stat;
    window.fs.stat = function(path, callback) {
      // callback();
      path = "/asdf"; // TODO: gotta unhardcode this.
      return window.fs.statOriginal(path, function() {
        var retStat = arguments[1];

        // console.log('d4', arguments[0], JSON.stringify(arguments[1]));
        // console.log('d4', arguments[1]);
        if (retStat) {
          if (retStat.fileData) { delete retStat['fileData']; }
          retStat.atimeMs = retStat.atime.getTime();
          retStat.mtimeMs = retStat.mtime.getTime();
          retStat.ctimeMs = retStat.ctime.getTime();
          retStat.birthtimeMs = retStat.birthtime.getTime();
        }
        console.log('d4', retStat);

        return callback(arguments[0], retStat);
        // return callback(...arguments);
      });
      // stat(path, callback) { callback(enosys()); },
    }

    // // TODO: to really make it work.
    // window.fs.mkdir = function() {
    //   console.log('mkdir?')
    // }

    init();
  });


// @Hau this is the test harness you should tinker with. Ignore above <script>
async function init() {
  const go = new Go();
  // let result = await WebAssembly.instantiateStreaming(fetch("basic.wasm"), go.importObject)
  // let result = await WebAssembly.instantiateStreaming(fetch("sdkver.wasm"), go.importObject)
  let result = await WebAssembly.instantiateStreaming(fetch("proxy.wasm"), go.importObject)
  go.run(result.instance);
  console.log(initializeConfig(
    "0afc093ffb509f059c55478bc1a60351cef7b4e9c008a53a6cc8241ca8617dfe",
    "bls0chain", 31082 /*port*/, "http://nine.devnet-0chain.net/dns",
    // "bls0chain", 31082 /*port*/, "http://six.devnet-0chain.net/dns",
    // "bls0chain", 31082 /*port*/, "https://seven.devnet-0chain.net/dns",
    10 /*cleanup worker minutes*/));

  const wallet = {"client_id":"315f086bbfd16036323ff580a347583a7f028b6800e72973974b02d339acdcfd","client_key":"041942fcff2a5c2f326aa6e60d1c7bf6ee6575077eeb6ff42503098f810e5bdd91061317c241d6c1f42b44f3608e6073b4d55bc4176adf322fa93066dd3300958b0e349b342dc3d5be818419d81b02174a56c53aa883048f08bb564a940aca0ad6117ed1caaf4eb8a4121ff8d8712dc1094a9c9e447dde77225f8f8fedf91d581e","keys":[{"public_key":"041942fcff2a5c2f326aa6e60d1c7bf6ee6575077eeb6ff42503098f810e5bdd91061317c241d6c1f42b44f3608e6073b4d55bc4176adf322fa93066dd3300958b0e349b342dc3d5be818419d81b02174a56c53aa883048f08bb564a940aca0ad6117ed1caaf4eb8a4121ff8d8712dc1094a9c9e447dde77225f8f8fedf91d581e","private_key":"232dd37c45ef952c8ddaa7d722039b3b16ab981dd6b63a880829106e69d44584"}],"mnemonics":"shine salon physical paddle clock pulp boost elite fine diet intact video awake lesson movie drift reject license spoil sample proof canal harvest grab","version":"1.0","date_created":"2021-06-11 07:31:57.099459 -0500 CDT m=+0.609355876"};

  const s_wallet = JSON.stringify(wallet);

  const alloc = "476e1f55c03fa66a115be2433438aca541fabc4a016e124357e35f34ce745219";

  let res = await GetClientEncryptedPublicKey(s_wallet);
  console.log(await res.text());

  // The herumi format of the public key is:
  // 23d5f2e6cd7f2d4973fb165d0adca5792c4dfba44146ddb24a562e702653190945b5bd10f08d5af80d130259caa8f553fbdff225decaf49a50476f8246167a96

  // Input parameters are all strings.

  // // Upload(method "POST" or "PUT", allocation, clientJSON, remotePath, Filename,
  // //   file /*e.g. contents of test.txt*/,
  // //   encrypt /*"T" or "F"*/,
  // //   fileAttrs)
  // console.log('running test')
  // let resUploadFile= await Upload(
  //   "POST",  // method
  //   alloc, // allocation
  //   s_wallet, // clientJSON
  //   "/", // remotePath
  //   "demo2.txt", // Filename
  //   "./demo.txt", // file contents
  //   "T", // encrypt
  //   "" // fileAttrs
  // )
  // console.log('running test, DONE')

  // // Download(allocation, clientJSON, remotePath, authTicket, numBlocks,
  // // rx_pay, file_name, lookuphash)
  // Download(
  //   alloc, // allocation
  //   s_wallet, // clientJSON
  //   "/", // remotePath
  //   "", // authTicket
  //   "0", // numBlocks
  //   "", // rx_pay
  //   "demo.txt", // file_name
  //   "" // lookuphash
  // )

  // let resDownloadFile= await Download(
  //   "4e863327cf888dfd6ae87ebc7dbd6771741a4d7a0288527f213dd9a243dffad4",
  //   `{"client_id":"1e843936880ed171a9855ef5c108fa3b8ac6bf 055ef9fc155065fd5538e31698","client_key":"09345640f6ebe04af038f5e0643ed55c812fce4f6b90144cd9ebc4b55b46b120dba3b7d3910031481007de5e7804bbf0e707dc972d1a44730309d7dafac7f394","keys":[{"public_key":"09345640f6ebe04af038f5e0643ed55c812fce4f6b90144cd9ebc4b55b46b120dba3b7d3910031481007de5e7804bbf0e707dc972d1a44730309d7dafac7f394","private_key":"31e77908dc0e301b058adc974e2ba7d06c0d2b5f1f3597224b5e6821bbe7871a"}],"mnemonics":"sponsor review enrich surround point file wrestle soup jungle gallery holiday employ sleep raw helmet length flame rail burst emerge comfort rookie agree insect","version":"1.0","date_created":"53344-06-08 09:13:51"}`,
  //   "/",
  //   "",
  //   "",
  //   "",
  //   "demo.txt",
  //   ""
  // )
  // Share(
  //   allocation,
  //   clientJSON,
  //   remotePath,
  //   refereeClientID,
  //   encryptionpublickey
  // )

  // // Tested!
  // await Rename(
  //   alloc,
  //   s_wallet, // clientJSON
  //   "/a.txt", // remotePath
  //   "b.txt" // newName
  // )

  // // Tested!
  // await Copy(
  //   alloc, // allocation
  //   s_wallet, // clientJSON
  //   "/dir1/demo2.txt", // remotePath
  //   "/" // destPath
  // )

  // // Tested!
  // await Delete(
  //   alloc,
  //   s_wallet, // clientJSON
  //   "/demo2.txt" // remotePath
  // )

  // // Tested!
  // await Move(
  //   alloc,
  //   s_wallet, // clientJSON
  //   "/dir1/demo2.txt", // remotePath
  //   "/" // destPath
  // )

}
</script>

  </head>
  <body></body>
</html>
